"""
Utilities for generating/manipulating latex files.

Some parts inspired by https://github.com/JelteF/PyLaTeX, but this module means to be more lightweight.
"""

import abc
import sys
from enum import Enum
from pathlib import Path
from typing import List, Optional, Union

from . import io, log

logger = log.get_logger("latex")

__all__ = ["LatexItem", "File"]


def escape(s: str) -> str:
    """
    Escapes a string for latex.
    """
    escaped = ""
    for c in s:
        if c in "&%$#_{}":
            escaped += "\\" + c
        elif c == "~":
            escaped += r"\textasciitilde{}"
        elif c == "^":
            escaped += r"\textasciicircum{}"
        elif c == "\\":
            escaped += r"\textbackslash{}"
        else:
            escaped += c
    return escaped


class LatexItem:
    @abc.abstractmethod
    def to_latex(self) -> str:
        raise NotImplementedError()


class File(LatexItem):
    class NewlineMode(Enum):
        auto = "auto"
        always = "always"
        never = "never"

    def __init__(
        self,
        path: Optional[Path] = None,
        auto_notice: bool = True,
        newline_mode: Union[NewlineMode, str] = NewlineMode.auto,
    ):
        """
        Creates a latex file which holds a list of items.
        :param path: the path to use when saving the file.
        :param auto_notice: whether to automatically add a notice comment in the generated file which contains the name of the script file and function.
        :param newline_mode: mode for inserting newlines between items:
            - auto: (default) insert newlines if the previous item doesn't end with newline.
            - always: always insert newlines.
            - never: never insert newlines.
        TODO: eventually make sure all items that are sensitive to newlines insert newlines for themselves, and change the default to never.
        """
        self.path: Optional[Path] = path
        self.auto_notice: bool = auto_notice
        self.newline_mode: File.NewlineMode = File.NewlineMode(newline_mode)
        self.items: List[LatexItem] = []

    def to_latex(self) -> str:
        out = ""
        for item in self.items:
            if self.newline_mode == File.NewlineMode.always:
                out += "\n"
            elif self.newline_mode == File.NewlineMode.auto and not out.endswith("\n"):
                out += "\n"
            out += item.to_latex()
        return out

    def save(self, path: Optional[Path] = None, exists: str = "overwrite"):
        """
        Saves the file to the given path.
        :param path: the path to save the file (can be provided either here or during the creation of a File instance).
        :param exists: the behavior when the file already exists:
            - overwrite: (default) overwrite the file.
            - append: append to the file.
            - error: raise an error.
        """
        if path is None:
            if self.path is None:
                raise ValueError("Path for saving the file not specified")
            path = self.path

        # the main content of the file
        s = self.to_latex()

        # add the auto notice
        if self.auto_notice:
            src = sys._getframe(1).f_code
            s = (
                f"%% Automatically generated by: {Path(src.co_filename).name} {src.co_name}\n"
                + s
            )

        # potentially deal with existing file
        if path.exists():
            if exists == "overwrite":
                logger.warning(f"Overwriting existing file at {path}")
            elif exists == "append":
                logger.info(f"Appending to existing file at {path}")
                s = io.load(path, io.Fmt.txt) + "\n" + s
            elif exists == "error":
                raise FileExistsError(f"File already exists at {path}")
            else:
                raise ValueError(f"Invalid parameter: {exists=}")
        io.dump(path, s, io.Fmt.txt)

    def append(self, item: Union[str, LatexItem], auto_newline: bool = True) -> "File":
        if isinstance(item, str):
            if auto_newline and not item.endswith("\n"):
                item += "\n"
            item = Text(item)
        self.items.append(item)
        return self

    def append_comment(self, s: str, auto_newline: bool = True) -> "File":
        if auto_newline and not s.endswith("\n"):
            s += "\n"
        return self.append(Comment(s))


class Text(LatexItem):
    def __init__(self, s: str):
        self.s = s

    def to_latex(self) -> str:
        return self.s


class Comment(LatexItem):
    def __init__(self, s: str):
        self.s = s

    def to_latex(self) -> str:
        return f"%% {self.s}"


class MacroUse(LatexItem):
    USEMACRO_COMMAND = "UseMacro"

    def __init__(self, key: str):
        self.key = key

    def to_latex(self) -> str:
        return "\\" + self.USEMACRO_COMMAND + "{" + self.key + "}"


class Macro(LatexItem):
    DEFMACRO_COMMAND = "DefMacro"

    def __init__(self, key: str, value: Optional[str] = None):
        self.key = key
        self.value = value

    def use(self) -> MacroUse:
        return MacroUse(self.key)

    def to_latex(self) -> str:
        if self.value is None:
            raise ValueError(f"Macro {self.key} has no value")
        s = "\\" + self.DEFMACRO_COMMAND + "{" + self.key + "}{" + self.value + "}"
        return s
