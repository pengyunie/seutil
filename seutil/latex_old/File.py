import sys
from pathlib import Path
from typing import Dict, List, Union

from .. import io, log
from .Macro import Macro
from .Table import Table

logger = log.get_logger("latex.File")


class File:
    def __init__(self, path: Path, is_append: bool = False):
        """
        Creates a latex file, currently for numbers/macros or tables.
        :param path: the path to the file.
        :param is_append: if set to true, then append to any existing file; otherwise overwrite the file.
        """
        self.path: Path = path
        self.is_append: bool = is_append

        self.old_content: str = ""
        if self.is_append:
            if path.is_file():
                self.old_content = io.load(path, io.Fmt.txt)

        # Contents
        self.items: List[Union[str, Macro, Table]] = list()
        self.macros_indexed: Dict[str, Macro] = dict()
        return

    def append(self, line: str) -> "File":
        """
        Appends one line of text into the file.
        """
        self.items.append(line)
        return self

    def append_macro(self, macro: Macro) -> "File":
        if macro.key in self.macros_indexed:
            logger.warning(f"Redefining macro {macro.key}")
        self.macros_indexed[macro.key] = macro
        self.items.append(macro)
        return self

    def append_comment(self, line: str) -> "File":
        self.items.append("%% " + line)
        return self

    def save(self) -> None:
        content = self.old_content + "\n" + self.eval_content()
        io.dump(self.path, content, io.Fmt.txt)
        return

    def eval_content(self) -> str:
        content_lines: List[str] = list()
        if not self.is_append:
            content_lines.append(self.autogen_notice())
        # end if
        for item in self.items:
            if isinstance(item, str):
                content_lines.append(item)
            elif isinstance(item, Macro):
                content_lines.append(item.eval_content(self.macros_indexed))
            else:
                logger.warning("Skipping unsupported item")
        return "\n".join(content_lines) + "\n"

    def load_macros_from_file(self, file: Path) -> "File":
        self.macros_indexed.update(Macro.load_from_file(file))
        return self

    def __iadd__(self, other: Union[str, Macro]):
        if isinstance(other, str):
            self.append(other)
        elif isinstance(other, Macro):
            self.append_macro(other)
        else:
            logger.warning("Skipping unsupported item")
        return self

    @classmethod
    def autogen_notice(cls) -> str:
        return f"%% Automatically generated by: {sys.argv[0]} \n"
